## 对象

### Set一个已有的数据会发生什么？

会发生覆盖

### 浮点型在String是用什么表示？

会先转为字符串值, 使用RAW还是EMBSTR编码, 取决于转换后字符串的长度

### String可以有多大？

最大为512M字节

### Redis字符串是怎么实现的？

如果是整数, 会用INT型编码, 其他类型较短的会用EMBSTR存储, 较长的用RAW存储

### 为什么EMBSTR的阈值是44？

### 你知道为什么EMBSTR曾经的阈值是39吗？

### SDS有什么用？

1. SDS包含已使用容量字段, 可以在O(1)时间返回字符串长度, 而C原生字符需要O(N)
2. 有预留空间, 扩容时如果预留空间足够, 不用重新分配内存, 缩容时也可以将减少的空间保留, 后续继续使用
3. 不以'\\0'作为结束标准, 二进制安全, 可以方便地存储二进制数据

### List是完全先入先出吗？

不是, 是双端操作对象

### List对象底层编码方式是什么？

ZIPLIST和LINKEDLIST, ZIPLIST适用于元素数量少, 元素较短的情况

3.2之后LIST编码都有QUICKLIST实现, 他是一个压缩列表组成的双向列表, 结合了ZIPLIST和LINKEDLIST的有点, 后面更新的版本将ZIPLIST优化为LISTPACK

### ZIPLIST是怎么压缩数据的？

ZIPLIST是紧凑型存储, 是在一片连续的内存空间上实现的双端链表, 普通双向链表使用指针连接, 每个元素都占用独立的一块内存, 会有大量的内存碎片. 而且ZIPLIST对于不同类型, 会有不同长度的数据存储, 尽可能压缩内存

### ZIPLIST下List可以从后往前遍历吗？

可以, 是双端操作对象, ZIPLIST每个节点都保存了上一个节点的长度, 以此来得出上一节点起始位置, 从而实现从后往前遍历

### 在ZIPLIST数据结构下，查询节点个数的时间复杂度是多少？

O(1), 因为数据结构定义了记录节点数量的字段, 如果超过65535个, 就需要O(n)来遍历得出个数

### LINKEDLIST编码下，查询节点个数的时间复杂度是多少？ 

O(1), LINKELIST数据结构中定义了链表所包含的节点数量的字段

### Set编码方式？

当数量较少且每个元素都为整数时, 使用INTSET, 否则使用HASHTABLE编码

### Set是有序的吗？

如果是INTSET编码则是有序的, HASHTABLE是无序的, 但是不应该依赖SET的顺序, 应该默认按无序使用

### Hash的编码方式是什么？

当数量较少且长度都比较小的时候, 使用ZIPLIST, 否则使用HASHTABLE

### Hash查找某个key的平均时间复杂度是多少？

当ZIPLIST编码时为O(n), HASHTABLE为O(1)

### Redis中HashTable查找元素总数的平均时间复杂度是多少?

O(1), 因为数据结构里定义了已存入的元素数量used

### 跳表中一个节点的层高是怎么决定的？

跳表插入新节点之前会计算一个随机层高, 具体来说就是每个节点默认为一层, 然后每增加一层的概率是25%, 最高为32层

# Redis执行

### Redis是单线程还是多线程

核心处理是单线程的, 6.0中使用多线程进行IO解包回包, 以及会使用多线程进行删除数据等异步任务

### Redis为什么选择单线程做核心处理

首先Redis是在内存中用k-v存储,  追求短平快, 性能瓶颈在于网络IO, 处理逻辑使用多线程收益并不会太大

其次如果使用多线程做核心处理, 会涉及很多上下文切换, 同步机制, 增加开销

综合来看, 如果使用多线程, 成本高且收益不大, 所以是用了单线程, 事实证明单线程也足够高效

### Redis单线程性能如何

性能很好, 一般每秒能十多万的读性能, 几万的写性能, 我在自己的Win主机上用redis-benchmark测的是

### 为什么单线程还能这么快

1. 基于内存操作
2. 高效的数据结构
3. IO多路复用, redis瓶颈在IO而不是CPU, IO多路复用刚好解决痛点

### Redis6.0之后引入了多线程，你知道为什么吗？

因为随着业务发展, 在部分高并发场景, 单核CPU有可能会出现性能不足, 所以针对核心处理流程中的解包回包这两个CPU耗时操作, 进行了多线程优化, 充分发挥多核优势

### Redis6.0的多线程是默认开启的吗？

不是, 需要在redis.conf配置文件中修改开启. 默认关闭一是为了向下兼容, 第二是多线程并不是必要的, 大多数场景不开启也完全够用

### Redis6.0的多线程主要负责命令执行的哪一块

负责原来核心流程中的IO处理, 包括解包和回包, 这两部分引入多线程主要是为了解决大数据下单核CPU不够用的问题

# Redis持久化

### RDB和AOF本质区别是什么？

本质区别是RDB是保存快照进行持久化, 而AOF是追加日志进行持久化

扩展:

文件恢复: RDB是二进制文件, 恢复速度比AOF更快

安全性: RDB容易丢失较多的数据, AOF根据策略决定(默认everysec可以保证最多有一秒的丢失)

操作开销: RDB是全量保存, 而AOF的刷盘是一次追加操作

### 如果RDB和AOF只能选一种，你选哪个？

从业务需求来看, 如果能接受分钟级别的数据丢失, 可以选择RDB, 如果需要尽量保证数据安全, 可以考虑混合持久化, 如果只用AOF, 优先选择everysec策略进行刷盘

从持久化理念来看, 始终开启快照是一个推荐方式, 这也是为什么redis官方默认开启RDB, 同时官网也明确不推荐只开AOF

### RDB的触发时机?

1. 执行save
2. 执行bgsave
3. 根据配置的周期进行
4. redis正常关闭

### AOF的触发时机?

1. redis关闭
2. 每一次时间循环 钩子函数beforesleep
3. 每一次时间循环函数severcron里

### RDB对主流程有什么影响？

当执行阻塞式持久化时, 由主进程进行RDB快照, 会阻塞主进程

当执行后台持久化时, 由fork出的子进程进行RDB快照

- 当数据量比较大时, 会导致fork子进程操作比较耗时, 从而阻塞主进程
- 由于采用写时复制技术, 如果在进行RDB快照保存时, 有大量写入操作执行, 会导致主进程多拷贝一份数据, 消耗大量额外的内存

### AOF混合持久化方案是什么？

混合持久化会使用RDB持久化函数, 将内存数据写入新的AOF文件, 而重写期间新的写入命令追加到新的AOF文件仍然是AOF格式

此时新的AOF文件就是由RDB格式和AOF格式组成的日志文件

### 简单描述AOF重写流程

一次拷贝, 两处缓存

主进程fork出一个子进程, 将redis中的数据以字符串命令格式写入新的AOF文件

如果有新数据, 主进程会将增量数据写入AOF重写缓冲区和AOF缓冲区中

将子进程将数据都写入到新AOF文件后, 主进程会通过管道将AOF重写缓冲区的数据发送给子进程, 子进程再将这份数据追加到新AOF文件中

### AOF重写你觉得有什么不足之处么？

### 针对AOF重写的不足，你有什么优化思路呢？

# Redis场景

### 你有实际使用过Redis做什么应用么？

有用redis做旁路缓存和分布式锁

### Redis缓存是如何应用的？

我们是用作旁路缓存, 项目中是先查询redis, 没有就查MySQL并将数据加载到redis

### Redis做旁路缓存，如果MySQL更新了，此时何去何从？

直接删除

### Redis做秒杀场景可以吗？讲讲思路

### Redis可以做消息队列吗？什么时候能用Redis做消息队列？

### 分布式锁实现要点是什么（其实就是怎么加锁、怎么解锁、怎么用）？

### 缓存问题（缓存穿透，缓存击穿，缓存雪崩）